const WebSocket = require("./Websocket");
const HTTP = require("./HTTP");
const MediaPlayer = require("./MediaPlayer");
class ServerManager {
  constructor(
    options = {
      reconnectDelay: 3000,
      reconnectMaxAttempts: 5,
      shardCount: 1,
      password: "",
      userID: 1234567890,
      url: "example.com",
      send: (guildId, packet) => {},
    }
  ) {
    this.options = options;
    this.servers = new Map();
    this.ws = new WebSocket(this, this.options);
    this.api = new HTTP(this.options.url, this.options.password, this.options);
    this.sendCallback = this.options.send;
  }

  /**
   *
   * @param {String} eventname
   * @param  {...any} args
   */

  on(eventname, ...args) {
    return this.ws.on(eventname, ...args);
  }

  /**
   *
   * @param {String} key
   * @returns {MediaPlayer}
   */
  get(key) {
    const server = this.servers.get(key);
    if (!server) {
      const newServer = new MediaPlayer(
        this.ws,
        { ...this.options, guildId: key },
        this.sendCallback
      );
      this.servers.set(key, newServer);
      return newServer;
    }
    return server;
  }

  search(SearchQuery) {
    return this.api.load(SearchQuery).then((response) => {
      const newTracks = response.tracks.map((f) => this.resolveTracks(f));
      return { ...response, tracks: newTracks };
    });
  }

  _resolveDuration(ms) {
    const durs = {
      second: 1000 * 1,
      minute: 1000 * 1 * 60,
      hour: 1000 * 1 * 60 * 60,
    };

    const hours = Math.trunc(ms / durs.hour) || 0;
    ms = ms - hours * durs.hour;
    const minutes = Math.trunc(ms / durs.minute) || 0;
    ms = ms - minutes * durs.minute;
    const seconds = Math.trunc(ms / durs.second) || 0;
    ms = ms - seconds * durs.second;
    let string = "";
    if (hours > 0) string = string + (hours.toString() + ":");
    if (hours > 0)
      string =
        string +
        (minutes.toString().length === 1
          ? "0" + minutes.toString() + ":"
          : minutes.toString() + ":");
    else string = string + (minutes.toString() + ":");
    string =
      string +
      (seconds.toString().length === 1
        ? "0" + seconds.toString()
        : seconds.toString());

    return string;
  }

  resolveTracks(Track) {
    const newTrack = {
      ...Track.info,
      track: Track.track,
      duration: this._resolveDuration(Track.info.length),
      thumbnail: Track.info.uri.includes("youtube")
        ? `https://img.youtube.com/vi/${Track.info.identifier}/default.jpg`
        : null,
      raw: Track,
    };

    return newTrack;
  }

  updateVoiceStates(packet) {
    if (!["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"].includes(packet.t || ""))
      return;
    let server = this.servers.get(packet.d.guild_id);
    if (!server) return;

    const state = server.voiceState || {};
    if (packet.t === "VOICE_SERVER_UPDATE") {
      state.op = "voiceUpdate";
      state.guildId = packet.d.guild_id;
      state.event = packet.d;
    } else {
      if (packet.d.user_id !== this.options.userID) return;
      state.sessionId = packet.d.session_id;
      if (packet.d.channel_id && server.voiceChannel !== packet.d.channel_id)
        server.voiceChannel = packet.d.channel_id;
    }
    server.voiceState = state;
    this.servers.set(packet.d.guild_id, server);
    if (
      JSON.stringify(Object.keys(state).sort()) ===
      JSON.stringify(["event", "guildId", "op", "sessionId"])
    ) {
      server.ws.send(state);
      const Tracks = server.queue;

      if (packet.d.channel_id === null)
        return this.servers.delete(packet.d.guild_id);
      if (packet.d.channel_id !== server.voiceChannel) {
        server.queue = Tracks;
        server.play({ start: server.timeState });
      }
      this.servers.set(packet.d.guild_id, server);
    }
  }
}

module.exports = ServerManager;
